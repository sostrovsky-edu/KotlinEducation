package data.type.classes.type.object_class.companion_object.example5

/**
 * В большинстве случаев можно ссылаться на объект-компаньон через имя содержащего его класса, поэтому не нужно
 * беспокоиться о выборе имени для него самого, если нет необходимости .
 * Если имя объекта-компаньона не указано, по-умолчанию выбирается имя Companion.
 *
 * Объект-компаньон класса компилируется так же, как обычный объект: статическое поле класса ссылается на собственный
 * экземпляр.
 * Если объект не имеет имени, к нему можно обратиться из Jаvа-кода через ссылку Companion:
 *      /* Java */
 *      Person.Companion.fromJSON("...");
 * Если у объекта есть имя, вместо Companion нужно использовать его. Но вам может понадобиться работать с Jаvа-кодом,
 * который требует, чтобы методы вашего класса были статическими. Для этого добавьте перед соответствующим методом
 * аннотацию @JvmStаtic.
 * Если понадобится объявить статическое поле, используйте аннотацию @JvmField перед свойством верхнего уровня или
 * свойством, объявленным в объекте. Эти аннотации нужны только для совместимости и, сгрого говоря, не являются
 * частью ядра языка.
 */
fun main() {
    val person = Person.Loader.fromJSON("{ name:'Dmitry' }")
    println("Person name from json is: ${person.name}")
}

class Person(val name: String) {
    companion object Loader {
        fun fromJSON(jsonText: String) : Person {
            var data = jsonText.substringAfter(":")
                                .replace("\'", "")
                                .replace("}", "")
                                .trim()

            return Person(data)
        }
    }
}